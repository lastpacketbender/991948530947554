S: 00 WELCOME lastpacketbender's TCP server; written in Python 3.10
C: S: 01 OK 
S: _='_=%r;print(_%%_)';print(_%_)
S: .
C: C: S: 01 OK 
S: #!/usr/bin/env python3
S: import logging
S: # Secure random
S: from secrets import SystemRandom
S: import socketserver
S: import sys
S: import threading
S: import types
S: import re
S: from math import gcd
S: logging.basicConfig(level=logging.DEBUG, format='%(name)s: %(message)s')
S: ############################# CONSTANTS #############################
S: server_prefix = 'S:'
S: client_prefix = 'C:'
S: banner = f"""lastpacketbender's TCP server; written in Python 3.10"""
S: status_codes = {
S:     '00': 'WELCOME',
S:     '01': 'OK',
S:     '02': 'ERROR',
S:     '03': 'DATA',
S:     '99': 'GOODBYE'
S: }
S: base29_charset = '0123456789ABCDEFGHIJKLMNOPQRS'
S: koan_text = [ "The Surangama scripture says, \"When I do not see, why do you not see my not seeing?",
S:         "If you see my not seeing, naturally that is not the characteristic of not seeing.",
S:         "If you don't see my not seeing, it is naturally not a thing-how could it not be you?\""]
S: ############################# GLOBALS ##############################
S: # NOTE: Does NOT need to be seeded, it is an unused param from doc
S: #
S: # To create cryptographically secure integers, I'm using Py3's
S: # secrets module which reads from system's secure /dev/random.
S: ####################################################################
S: # TODO: Look at rootkit to see if /dev/urandom and random are the
S: # same character device now. Recent kernel changes increased speed
S: # and I remember having to fix a hook for injecting cyclic patterns.
S: system_random = SystemRandom()
S: # Diffie-hellman sessions currently under negotiation
S: negotiating = {}
S: ############################# MATH ##############################
S: class DH:
S:     """ Key exchange session wrapper """
S:     def __init__(self, p):
S:         self.p = p
S:         self.b = system_random.choice(primitive_roots(self.p))
S:         self.a = int(system_random.random())
S:         self.e = self.b ** self.a % self.p
S:         self.e2 = None
S:         self.s = None
S: def primitive_roots(modulo):
S:     required_set = {num for num in range(1, modulo) if gcd(num, modulo) }
S:     return [g for g in range(1, modulo)
S:             if required_set == {pow(g, powers, modulo)
S:             for powers in range(1, modulo)}]
S: def is_prime(n):
S:     if n < 3 or n % 2 == 0:
S:         return n == 2
S:     else:
S:         return not any(n % i == 0 for i in range(3, int(n**0.5 + 2), 2))
S: ############################# SERVER COMMANDS #############################
S: # NOTE: Executed after lexical analysis/parsing within Parser
S: #
S: # listener loop->lexer->parser->command
S: ###########################################################################
S: def rand(n):
S:     for _ in range(n):
S:         yield system_random.randint(0, 255)
S: def quine():
S:     # eval to ensure quine is self replicating
S:     return "_='_=%r;print(_%%_)';print(_%_)"
S: def base29(n, b=29):
S: 	if n == 0:
S: 		return '0'
S: 	digits = ''
S: 	while n:
S: 		digits += base29_charset[int(n % b)]
S: 		n //= b
S: 	return digits[::-1]
S: def code():
S:     with open(__file__) as f:
S:         for line in f.readlines():
S:             yield line#.rstrip()
S: def koan():
S:     for line in koan_text:
S:         yield line
S: def dh(p, session=None):
S:     if not session:
S:         return DH(int(p))
S:     else:
S:         session.e2 = int(p)
S:         session.s = session.e2 ** session.a % session.p
S:         return session
S: def _next(data=None):
S:     if data:
S:         for line in data:
S:             yield line
S: def goodbye():
S:     pass
S: ############################# Lexer/Parser #############################
S: class Parser:
S:     @staticmethod
S:     def parse(tokens, session=None):
S:         token_iter = iter(tokens)
S:         for token in token_iter:
S:             if token == "RAND":
S:                 n = int(next(token_iter))
S:                 return rand(n)
S:             elif token == "QUINE":
S:                 return quine()
S:             elif token == "BASE29":
S:                 n = int(next(token_iter))
S:                 return base29(n)
S:             elif token == "CODE":
S:                 return code()
S:             elif token == "KOAN":
S:                 return koan()
S:             elif token == "DH":
S:                 p = int(next(token_iter))
S:                 return dh(p)
S:             elif token == "NEXT":
S:                 # Essentially a NOP
S:                 return _next()
S:             elif token == "GOODBYE":
S:                 return goodbye()
S:             # DH key exchange
S:             elif token.isdigit():
S:                 return dh(token, session)
S: class Lexer:
S:     logger = logging.getLogger('Lexer')
S:     cmd_narg_map = {
S:             "RAND": 1,
S:             "QUINE": 0,
S:             "BASE29": 1,
S:             "CODE": 0,
S:             "KOAN": 0,
S:             "DH": 1,
S:             "NEXT": 0,
S:             "GOODBYE": 0
S:     }
S:     def __init__(self, msg):
S:         self.command = msg
S:         self.tokens = msg.split()
S:     def lex(self, exchanging=False):
S:         if not self.command.endswith("\r\n"):
S:             return False, "MISSING <CRLF>"
S:         if exchanging:
S:             if len(self.tokens) > 1:
S:                 return False, "INVALID NUMBER OF PARAMETERS DURING NEGOTIATION"
S:             if not self.tokens[0].isdigit():
S:                 return False, "PARAMETER NOT A NUMBER DURING NEGOTIATION"
S:             return True, None
S:         no_arg_cmds = [k for k,v in self.cmd_narg_map.items() if v == 0]
S:         one_arg_cmds = [k for k,v in self.cmd_narg_map.items() if v == 1]
S:         print(self.tokens)
S:         if len(self.tokens) > 2:
S:             return False, "INVALID NUMBER OF PARAMETERS"
S:         elif self.tokens[0] in no_arg_cmds:
S:             if len(self.tokens) != 1:
S:                 return False, "INVALID NUMBER OF PARAMETERS"
S:         elif self.tokens[0] in one_arg_cmds:
S:             if len(self.tokens) != 2:
S:                 return False, "INVALID NUMBER OF PARAMETERS"
S:             if not self.tokens[1].isdigit():
S:                 return False, "PARAMETER NOT A NUMBER"
S:             if self.tokens[0] == "DH":
S:                 if not is_prime(int(self.tokens[1])):
S:                     return False, "NOT PRIME"
S:         else:
S:             return False, "SYNTAX ERROR"
S:         return True, None
S: ############################# Server/main #############################
S: class Handler(socketserver.BaseRequestHandler):
S:     logger = logging.getLogger('Handler')
S:     # FIXME: What if multiple users connect from behind the same router
S:     # Add another attribute to uniquely identify them
S:     welcomed = set()
S:     # Clients with a pending NEXT
S:     waiting = set()
S:     mutex = threading.Lock()
S:     @staticmethod
S:     def get_status(code):
S:         return code, status_codes[code]
S:     def tx(self, code='', msg='', terminator=False, prompt=False):
S:         # possible FIXME
S:         msg = msg.rstrip()
S:         if code:
S:             code, status = self.get_status(code)
S:             self.request.sendall(f"{server_prefix} {code} {status} {msg}\r\n".encode())
S:         elif prompt:
S:             self.request.sendall(f"{client_prefix} ".encode())
S:         else:
S:             if msg:
S:                 self.request.sendall(f"{server_prefix} {msg}\r\n".encode())
S:                 if terminator:
S:                     self.request.sendall(f"{server_prefix} .\r\n".encode())
S:             elif terminator:
S:                 self.request.sendall(f"{server_prefix} .\r\n".encode())
S:     def rx(self, msg=''):
S:         # possible FIXME
S:         print(f"{client_prefix} {msg}".decode('utf-8'))
S:     def negotiation(self):
S:         return negotiating[self.client_address[0]] if self.is_negotiating() else None
S:     def is_negotiating(self):
S:         return self.client_address[0] in negotiating
S:     def commands(self, tokens=None, data=None):
S:         close = False
S:         if data:
S:             result = _next(data)
S:             if isinstance(result, types.GeneratorType):
S:                 for i in result:
S:                     if isinstance(i, str):
S:                         self.rx(msg=i)
S:             return False
S:         elif tokens and tokens[0] == "NEXT" and not data:
S:             self.tx('01')
S:             with self.mutex:
S:                 self.waiting.add(self.client_address[0])
S:             return False
S:         if tokens[0] == "GOODBYE":
S:             self.tx('99')
S:             return True
S:         # Sequencing of OK message different for DH, doesn't exist on GOODBYE
S:         if tokens[0] not in ["DH"] and not tokens[0].isdigit() and self.client_address[0] not in self.waiting:
S:             # 01 OKAY - send acknowledgement of valid command
S:             self.tx('01')
S:         result = Parser.parse(tokens, session=self.negotiation())
S:         # Add client to negotiating sessions
S:         if tokens[0] == "DH":
S:             negotiating[self.client_address[0]] = result
S:         # Transmit message and terminate with . for generator types
S:         if isinstance(result, types.GeneratorType):
S:             for i in result:
S:                 if isinstance(i, str):
S:                     self.tx(msg=i)
S:                 elif isinstance(i, int):
S:                     self.tx(msg=str(i))
S:             self.tx(terminator=True)
S:         elif isinstance(result, str):
S:             if tokens[0] == "QUINE":
S:                 self.tx(msg=result, terminator=True)
S:             elif tokens[0] == "BASE29":
S:                 self.tx(msg=result)
S:         else:
S:             # We parsed a key exchange container
S:             if tokens[0] == "DH" or (tokens[0].isdigit() and self.is_negotiating()):
S:                 if not result.s:
S:                     # Secret generated, send b and e to client
S:                     self.tx('01', f"{result.b} {result.e}")
S:                 else:
S:                     self.tx('03', str(result.s))
S:                     negotiating.pop(self.client_address[0])
S:         return close
S:     def welcome(self):
S:         if self.client_address[0] not in self.welcomed:
S:             self.tx('00', banner)
S:             self.welcomed.add(self.client_address[0])
S:     def handle(self):
S:         self.welcome()
S:         close = False
S:         client = self.client_address[0]
S:         while True:
S:             self.tx(prompt=True)
S:             # FIXME: Handle oversized data
S:             if not client in self.waiting:
S:                 self.data = self.request.recv(1024).upper()
S:                 print("in not waiting")
S:             else:
S:                 # Don't strip or convert sensitive data to uppercase, we need valid signatures
S:                 self.data = self.request.recv(1024)
S:                 print("in waiting")
S:             # empty data, client quit writing to socket
S:             if not self.data:
S:                 break
S:             cmd = self.data.decode('utf-8')
S:             self.logger.debug("{} wrote: {}".format(client, cmd))
S:             # Receive data
S:             if client in self.waiting:
S:                 # self.data = self.request.recv(1024)
S:                 if isinstance(self.data, types.GeneratorType):
S:                     for i in result:
S:                         if isinstance(i, str):
S:                             self.rx(msg=i)
S:                 # Bypass lexing for data
S:                 if self.data.endswith(b".\r\n"):
S:                     with self.mutex:
S:                         self.waiting.remove(client)
S:                     self.tx('01')
S:             # Lexical analysis
S:             else:
S:                 lexer = Lexer(cmd)
S:                 pass_analysis, error_msg = lexer.lex(exchanging=self.is_negotiating())
S:                 if not pass_analysis:
S:                     self.tx('02', error_msg)
S:                 else:
S:                     # Handoff to command handler for parsing/execution
S:                     close = self.commands(lexer.tokens)
S:             if close:
S:                 self.welcomed.remove(client)
S:                 break
S: class Server(socketserver.ThreadingMixIn, socketserver.TCPServer):
S:     def __init__(self, server_address,
S:                  handler_class=Handler,):
S:         self.logger = logging.getLogger('Server')
S:         self.logger.debug('__init__')
S:         socketserver.TCPServer.__init__(self, server_address,
S:                                         handler_class)
S:         return
S:     def server_activate(self):
S:         self.logger.debug('server_activate')
S:         socketserver.TCPServer.server_activate(self)
S:         return
S:     def serve_forever(self, poll_interval=0.5):
S:         self.logger.debug('waiting for request')
S:         self.logger.info(
S:             'Handling requests, press <Ctrl-C> to quit'
S:         )
S:         socketserver.TCPServer.serve_forever(self, poll_interval)
S:         return
S:     def handle_request(self):
S:         self.logger.debug('handle_request')
S:         return socketserver.TCPServer.handle_request(self)
S:     def verify_request(self, request, client_address):
S:         self.logger.debug('verify_request(%s, %s)',
S:                           request, client_address)
S:         return socketserver.TCPServer.verify_request(
S:             self, request, client_address,
S:         )
S:     def process_request(self, request, client_address):
S:         self.logger.debug('process_request(%s, %s)',
S:                           request, client_address)
S:         return socketserver.TCPServer.process_request(
S:             self, request, client_address,
S:         )
S:     def server_close(self):
S:         self.logger.debug('server_close')
S:         return socketserver.TCPServer.server_close(self)
S:     def finish_request(self, request, client_address):
S:         self.logger.debug('finish_request(%s, %s)',
S:                           request, client_address)
S:         return socketserver.TCPServer.finish_request(
S:             self, request, client_address,
S:         )
S:     def close_request(self, request_address):
S:         self.logger.debug('close_request(%s)', request_address)
S:         return socketserver.TCPServer.close_request(
S:             self, request_address,
S:         )
S:     def shutdown(self):
S:         self.logger.debug('shutdown()')
S:         return socketserver.TCPServer.shutdown(self)
S: if __name__ == "__main__":
S:     if len(sys.argv) < 2 or not sys.argv[1].isdigit():
S:         print("USAGE: ./server.py <PORT NUM>")
S:         exit(3301)
S:     HOST, PORT = "localhost", int(sys.argv[1])
S:     with Server((HOST, PORT), Handler) as server:
S:         ip, port = server.server_address
S:         server_thread = threading.Thread(target=server.serve_forever)
S:         server_thread.setDaemon(True)
S:         server_thread.start()
S:         logger = logging.getLogger('Server')
S:         logger.info('Server on %s:%s', ip, port)
S:         try:
S:             while True:
S:                 server.handle_request()
S:         except KeyboardInterrupt:
S:             logger.info('interrupt received, terminating...')
S:             server.shutdown()
S:             server.socket.close()
S: .
C: C: S: 01 OK 
S: The Surangama scripture says, "When I do not see, why do you not see my not seeing?
S: If you see my not seeing, naturally that is not the characteristic of not seeing.
S: If you don't see my not seeing, it is naturally not a thing-how could it not be you?"
S: .
C: C: S: 01 OK 
S: 107
S: 168
S: 92
S: 131
S: 70
S: 178
S: 110
S: 58
S: 10
S: 88
S: 89
S: 244
S: 123
S: 197
S: 142
S: 100
S: 199
S: 39
S: 216
S: 116
S: 144
S: 147
S: 170
S: 67
S: 87
S: 207
S: 2
S: 211
S: 197
S: 199
S: 164
S: 92
S: 181
S: 197
S: 29
S: 167
S: 10
S: 48
S: 44
S: 72
S: 222
S: 133
S: 99
S: 186
S: 198
S: 236
S: 145
S: 231
S: 41
S: 243
S: 18
S: 199
S: 213
S: 48
S: 141
S: 223
S: 247
S: 125
S: 240
S: 88
S: 141
S: 147
S: 240
S: 102
S: 223
S: 106
S: 37
S: 9
S: 218
S: 183
S: 19
S: 105
S: 46
S: 255
S: 108
S: 102
S: 58
S: 150
S: 124
S: 134
S: 80
S: 60
S: 44
S: 41
S: 110
S: 240
S: 91
S: 8
S: 146
S: 17
S: 44
S: 136
S: 49
S: 215
S: 212
S: 178
S: 72
S: 31
S: 3
S: 66
S: .
C: C: S: 01 OK 
S: 3QO
C: C: S: 02 ERROR MISSING <CRLF>
C: S: 02 ERROR MISSING <CRLF>
C: S: 02 ERROR MISSING <CRLF>
C: S: 02 ERROR INVALID NUMBER OF PARAMETERS
C: C: S: 99 GOODBYE 
S: 00 WELCOME lastpacketbender's TCP server; written in Python 3.10
C: S: 01 OK 15 1
C: C: S: 03 DATA 1
C: C: S: 99 GOODBYE 
